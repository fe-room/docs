(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{530:function(e,t,a){"use strict";a.r(t);var s=a(6),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[e._v("#")]),e._v(" 原因")]),e._v(" "),a("p",[e._v("依赖预构建会提升页面重载速度，这个过程中会执行依赖与绑定，有两个目的。")]),e._v(" "),a("ol",[a("li",[e._v("将CommonJS/UMD转换为ESM格式，处理兼容性问题，在转换的CommonJS依赖时，会智能导入分析，即使导出是动态分配的（如 React），按名导入也会符合预期效果。")]),e._v(" "),a("li",[e._v("性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from 'lodash-es' 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。")])]),e._v(" "),a("p",[e._v("通过预构建 lodash-es 成为一个模块，我们就只需要一个 HTTP 请求了！")]),e._v(" "),a("h1",{attrs:{id:"自动依赖搜寻"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动依赖搜寻"}},[e._v("#")]),e._v(" 自动依赖搜寻")]),e._v(" "),a("p",[e._v('如果没有找到存在的缓存，Vite 将抓取你的源代码，并自动发现依赖项导入（即 "裸引入"，期望从 node_modules 解析），并使用这些发现的导入作为预构建包的入口点。预绑定是用 esbuild 执行的，所以它通常非常快。')]),e._v(" "),a("p",[e._v("在服务器已经启动之后，如果在缓存中没有遇到新的依赖项导入，Vite 将重新运行依赖构建进程并重新加载页面。")]),e._v(" "),a("h1",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[e._v("#")]),e._v(" 缓存")]),e._v(" "),a("h2",{attrs:{id:"文件系统缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件系统缓存"}},[e._v("#")]),e._v(" 文件系统缓存")]),e._v(" "),a("p",[e._v("Vite 会将预构建的依赖缓存到 node_modules/.vite。它根据几个源来决定是否需要重新运行预构建步骤:")]),e._v(" "),a("ul",[a("li",[e._v("package.json 中的 dependencies 列表")]),e._v(" "),a("li",[e._v("包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml")]),e._v(" "),a("li",[e._v("可能在 vite.config.js 相关字段中配置过的")])]),e._v(" "),a("h2",{attrs:{id:"浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[e._v("#")]),e._v(" 浏览器缓存")]),e._v(" "),a("p",[e._v("解析后的依赖请求会以 HTTP 头 max-age=31536000,immutable 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器。如果安装了不同的版本（这反映在包管理器的 lockfile 中），则附加的版本 query 会自动使它们失效。如果你想通过本地编辑来调试依赖项，你可以:")]),e._v(" "),a("ol",[a("li",[e._v("通过浏览器 devtools 的 Network 选项卡暂时禁用缓存；")]),e._v(" "),a("li",[e._v("重启 Vite dev server，使用 --force 标志重新打包依赖；")]),e._v(" "),a("li",[e._v("重新载入页面。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);